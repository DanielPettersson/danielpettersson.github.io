<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<title>Rubik</title>
		<style>
			body { margin: 0; }
			canvas { display: block; }
		</style>

        <script src="https://cdnjs.cloudflare.com/ajax/libs/tween.js/16.3.5/Tween.min.js"></script>

    </head>
    
	<body>

		<script type="module">

            import * as THREE from 'https://cdn.skypack.dev/three';
            import { RoundedBoxGeometry } from 'https://cdn.skypack.dev/three/examples/jsm/geometries/RoundedBoxGeometry.js';
          
            const renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);

            const scene = new THREE.Scene();
            const camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.1, 1000 );
            camera.position.set(2.5, 2, 5);
            camera.lookAt(0, 0, 0);

            const light = new THREE.DirectionalLight();
            light.position.set( 1, 1, 1 );
            scene.add( light )

            const light2 = new THREE.DirectionalLight(0xffffbb, 0.5);
            light2.position.set( -2, 0, 1 );
            scene.add( light2 )

            const geometry = new RoundedBoxGeometry();
            var pivot = new THREE.Object3D();

            const cubes = [];

            for (var x = -1; x <= 1; x++) {
                for (var y = -1; y <= 1; y++) {
                    for (var z = -1; z <= 1; z++) {
                        if (x == 0 && y == 0 && z == 0) continue;
                        const cube = new THREE.Mesh( geometry, new THREE.MeshStandardMaterial( { color: Math.random() * 0xffffff } ) );
                        cubes.push(cube);
                        cube.position.set(x, y, z);
                        
                        scene.add(cube);
                    }
                }
            }

            scene.add(pivot);


            window.addEventListener( 'resize', function() {
                renderer.setSize(window.innerWidth, window.innerHeight);
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
            }, false );


            var rotating = false;

            document.addEventListener('keydown', function(e) {
                if (!rotating) {
                    var dir = e.shiftKey ? -1 : 1;
                    if (e.code === 'KeyR') rotate(new THREE.Vector3(dir * 1, 0, 0), new THREE.Vector3(1, 0, 0));
                    else if (e.code === 'KeyL') rotate(new THREE.Vector3(dir * -1, 0, 0), new THREE.Vector3(-1, 0, 0));
                    else if (e.code === 'KeyF') rotate(new THREE.Vector3(0, 0, dir * 1), new THREE.Vector3(0, 0, 1));
                    else if (e.code === 'KeyB') rotate(new THREE.Vector3(0, 0, dir * -1), new THREE.Vector3(0, 0, -1));
                    else if (e.code === 'KeyU') rotate(new THREE.Vector3(0, dir * 1, 0), new THREE.Vector3(0, 1, 0));
                    else if (e.code === 'KeyD') rotate(new THREE.Vector3(0, dir * -1, 0), new THREE.Vector3(0, -1, 0));
                    else if (e.code === 'KeyX') rotate(new THREE.Vector3(dir * 1, 0, 0), null);
                    else if (e.code === 'KeyY') rotate(new THREE.Vector3(0, dir * 1, 0), null);
                    else if (e.code === 'KeyZ') rotate(new THREE.Vector3(0, 0, dir * 1), null);
                }
            });

            function rotate(axis, layer) {

                rotating = true;
                    
                cubes.forEach(c => {

                    const wp = new THREE.Vector3(0, 0, 0);
                    const wr = new THREE.Quaternion();
                    c.getWorldPosition(wp);
                    c.getWorldQuaternion(wr);

                    c.position.copy(wp);
                    c.setRotationFromQuaternion(wr);

                    c.removeFromParent();
                });
                pivot.rotation.x = 0;
                pivot.rotation.y = 0;
                pivot.rotation.z = 0;

                cubes.forEach(c => {

                    if (layer) {
                        const wp = new THREE.Vector3(0, 0, 0);
                        c.getWorldPosition(wp);
                        if (layer.x !== 0 && Math.abs(layer.x - wp.x) < 0.001) pivot.add(c);
                        if (layer.y !== 0 && Math.abs(layer.y - wp.y) < 0.001) pivot.add(c);
                        if (layer.z !== 0 && Math.abs(layer.z - wp.z) < 0.001) pivot.add(c);
                        if (c.parent == null) scene.add(c);
                    } else {
                        pivot.add(c);
                    }

                })
                

                var pd = 0;
                new TWEEN.Tween({d: 0})
                                .to({d: -Math.PI / 2}, 500)
                                .onUpdate(function() { 
                                    pivot.rotateOnWorldAxis(axis, this.d - pd)
                                    pd = this.d;
                                })
                                .onComplete(function() { rotating = false; })
                                .easing(TWEEN.Easing.Quartic.InOut)
                                .start();
            }


            function render(time) {

                requestAnimationFrame(render);

                renderer.render(scene, camera);
                TWEEN.update(time);
                
            }


            requestAnimationFrame(render);
          
          </script>

	</body>
</html>